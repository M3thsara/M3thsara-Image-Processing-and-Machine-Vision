import cv2 as cv     #open opencv
import numpy as np
import matplotlib.pyplot as plt
from skimage.feature import blob_log

image = cv.imread('/content/drive/MyDrive/Images - EN3160 IPMV/a2images/the_berry_farms_sunflower_field.jpeg',cv.IMREAD_REDUCED_COLOR_4)
assert image is not None

fig, ax = plt.subplots(figsize=(10, 10))
plt.title('Original Image')
plt.imshow(cv.cvtColor(image, cv.COLOR_BGR2RGB))
plt.axis('off')
plt.show()

# Function to create the Laplacian of Gaussian kernel

def generate_log_kernel(kernel_size, std_dev):
    axis = np.linspace(-(kernel_size // 2), kernel_size // 2, kernel_size)
    x_vals, y_vals = np.meshgrid(axis, axis)
    
    # Calculate the Laplacian of Gaussian
    log_filter = (x_vals**2 + y_vals**2 - 2 * std_dev**2) * np.exp(-(x_vals**2 + y_vals**2) / (2 * std_dev**2))
    return log_filter

# Define range of sigma values
sigma_values = np.linspace(7, 11, 40)
filtered_images_with_circles = []

# Loop through each sigma value and apply the filter
for sigma in sigma_values:
    # Apply the filter to the grayscale image
    log_filtered = cv.filter2D(cv.cvtColor(image, cv.COLOR_BGR2GRAY), -1, generate_log_kernel(35, sigma) * sigma**2)
    
    # Normalize the filtered image for better visualization
    norm_image = cv.normalize(log_filtered, None, 0, 255, cv.NORM_MINMAX)
    
    # Convert to binary using thresholding
    _, binary_thresh = cv.threshold(np.uint8(norm_image), 200, 255, cv.THRESH_BINARY)
    
    # Find where the binary image is greater than 0
    y_coords, x_coords = np.where(binary_thresh > 0)
    img_copy = image.copy()
    
    # Draw circles at the detected coordinates
    for x, y in zip(x_coords, y_coords):
        cv.circle(img_copy, (x, y), round(sigma * np.sqrt(2)), (255, 255, 255), 1)  # Draw white circles

    filtered_images_with_circles.append(img_copy)

# Set up the subplot layout for displaying the results
columns = 4
total_images = len(filtered_images_with_circles)
rows = (total_images + columns - 1) // columns

# Plot all filtered images with circles
plt.figure(figsize=(15, 5 * rows))  # Adjust figure size based on the number of rows
for idx, result_image in enumerate(filtered_images_with_circles):
    plt.subplot(rows, columns, idx + 1)
    plt.imshow(cv.cvtColor(result_image, cv.COLOR_BGR2RGB))
    plt.title(f'Sigma: {sigma_values[idx]:.1f}')
    plt.axis('off')

plt.tight_layout()
plt.show()

import numpy as np
import cv2

# Function to create the Laplacian of Gaussian kernel
def generate_log_filter(filter_size, sigma_value):
    axis = np.linspace(-(filter_size // 2), filter_size // 2, filter_size)
    x_grid, y_grid = np.meshgrid(axis, axis)
    
    # Compute Laplacian of Gaussian
    log_filter = (x_grid**2 + y_grid**2 - 2 * sigma_value**2) * np.exp(-(x_grid**2 + y_grid**2) / (2 * sigma_value**2))
    return log_filter

# Function to detect blobs at multiple scales
def blob_detection(image_gray, sigma_range):
    height, width = image_gray.shape[:2]
    scale_space = np.zeros((height, width, len(sigma_range)))
    
    for idx, sigma_value in enumerate(sigma_range):
        kernel_size = int(6 * sigma_value) | 1  # Ensuring the kernel size is odd
        log_filter = generate_log_filter(kernel_size, sigma_value)
        
        # Filter the image
        filtered_image = cv2.filter2D(image_gray, -1, log_filter * sigma_value**2)
        scale_space[:, :, idx] = filtered_image
        
    return scale_space

# Function to find blobs by looking for extrema in scale-space
def locate_blobs(scale_space, threshold_value=50):
    detected_blobs = []
    height, width, scale_levels = scale_space.shape

    for scale_idx in range(1, scale_levels - 1):
        current_layer = scale_space[:, :, scale_idx]
        previous_layer = scale_space[:, :, scale_idx - 1]
        next_layer = scale_space[:, :, scale_idx + 1]

        # Finding local maxima
        maxima = (current_layer > previous_layer) & (current_layer > next_layer) & (current_layer > threshold_value)

        # Get coordinates of detected blobs
        y_points, x_points = np.where(maxima)

        # Add blob coordinates and scale (sigma)
        for y, x in zip(y_points, x_points):
            detected_blobs.append((x, y, sigma_range[scale_idx]))

    return detected_blobs

# Function to draw circles around detected blobs
def visualize_blobs(input_image, blobs):
    output_image = input_image.copy()
    
    for x_coord, y_coord, sigma_value in blobs:
        circle_radius = int(sigma_value * np.sqrt(2))
        cv2.circle(output_image, (x_coord, y_coord), circle_radius, (0, 255, 0), 1)
    
    return output_image

# Load the image and convert it to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Define range of sigma values
sigma_range = np.linspace(7, 10, 10)

# Detect blobs by filtering the image
scale_space_result = blob_detection(gray_image, sigma_range)
detected_blobs = locate_blobs(scale_space_result, threshold_value=50)

# Draw the blobs on the original image
final_image = visualize_blobs(image, detected_blobs)

# Show the result
from google.colab.patches import cv2_imshow

cv2_imshow(final_image)
